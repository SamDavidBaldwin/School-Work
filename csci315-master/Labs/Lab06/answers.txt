1.1) There aren't any easily observable errors on every run, but in some executions of the program, there are cases in which adjacent philosophers are both hungry, and trying to access chopsticks but they cannot eat because those chopsticks are being utilized by other philosophers. One example of this is a case where 3 is waiting on 2, and 4 is waiting on 3 and 5. This results in a case of deadlock.
1.2) Cases where deadlock could occur are when any given philosopher is awaiting the resources on both sides in this case the chopsticks, but there is a case in which that philosopher is locked out of accessing the resource at all time by at least one of the philosophers on either side accessing the resource. For example, philosopher 3 could be locked out of eating if either philosopher on their side was using chopsticks. Like if 4 was using a chopstick, but before 4 put the chopstick
down, 2 picked the chopstick up. This illustrates the hold and wait and mutual exclusion concepts of deadlock. The circular wait principle is satisfied as the exact nature of the problem is that the philosophers are sitting at a circular table, as enforced by the use of modulus operators. The final condition of deadlock, no preemption is satisfied by the nature of mutexes,which prevent a philosopher from preemptively gaining access to the chopstick while another is still eating.

2.1) The situation in which I observed and recorded that occured in deadlock was every philosopher taking the chopstick to their left, resulting in no singular philsopher getting to eat. This is beacuse every philosopher is waiting on  the philosopher to the right, in a circular nature, and no philosopher can execute.

3.1) Because these two different solutions break symmetry, they remove the cases in which there is a cyclicak waiting nature. This ultimately removes the issue of circular wait from the deadlock problem ultimately removing the deadlocking issue in the dining philosophers problem. Therefore, deadlock can no longer occur with these two solutions.
